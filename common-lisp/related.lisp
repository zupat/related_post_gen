(declaim (optimize (speed 3) (safety 1)))

;; Install/load json lib
(ql:quickload :com.inuoe.jzon)

;; Main program
(in-package :cl-user)

(defconstant +top-n+ 5)

(defstruct post
  (id nil :type simple-string)
  (tags nil :type simple-vector)
  (title nil :type simple-string))

(defun tag-map-lists-to-arrays (tag-map)
  (maphash (lambda (tag indices)
             (let* ((len (length indices))
                    (v (make-array len :element-type '(unsigned-byte 32))))
               (declare (type fixnum len)
                        (type (simple-array (unsigned-byte 32) (*)) v))
               (loop for index in indices
                 for i fixnum from 0
                 do (setf (aref v i) index))
               (setf (gethash tag tag-map) v)))
           tag-map)
  tag-map)

(defun build-tag-map (posts)
  (declare (type simple-vector posts))
  (let ((tag-map (make-hash-table :size 100 :test 'equal)))
    (dotimes (i (length posts))
      (let ((tags (post-tags (aref posts i))))
        (declare (type simple-vector tags))
        (loop for tag across tags do
          (push i (gethash tag tag-map)))))
    (tag-map-lists-to-arrays tag-map)))

(defun all-related (i posts tag-map shared-counts)
  (declare (type fixnum i)
           (type simple-vector posts)
           (type (simple-array (unsigned-byte 8) (*)) shared-counts))
  (fill shared-counts 0)
  (let* ((post (aref posts i))
         (tags (post-tags post)))
    (declare (type simple-vector tags))
    (loop for tag across tags do
      (let ((indices (gethash tag tag-map)))
        (declare (type (simple-array (unsigned-byte 32) (*)) indices))
        (dotimes (j (length indices))
          (declare (type fixnum j))
          (incf (aref shared-counts (aref indices j))))))
    (setf (aref shared-counts i) 0)
    shared-counts))

(defun top-related (shared-counts top-counts top-indices)
  (declare (type (simple-array (unsigned-byte 8) (*)) shared-counts top-counts)
           (type (simple-array fixnum (*)) top-indices))
  (fill top-counts 0)
  (fill top-indices 0)
  (let ((last-slot (1- +top-n+)))
    (declare (type fixnum last-slot))
    (dotimes (index (length shared-counts))
      (declare (type fixnum index))
      (let ((count (aref shared-counts index)))
        (declare (type (unsigned-byte 8) count))
        (when (> count (aref top-counts last-slot))
          (let ((insert-pos last-slot))
            (declare (type fixnum insert-pos))
            (loop while (and (> insert-pos 0)
                             (> count (aref top-counts (1- insert-pos))))
              do (setf (aref top-counts insert-pos)
                       (aref top-counts (1- insert-pos))
                       (aref top-indices insert-pos)
                       (aref top-indices (1- insert-pos)))
              (decf insert-pos))
            (setf (aref top-counts insert-pos) count
                  (aref top-indices insert-pos) index)))))
    top-indices))

(defun make-related-post (post related)
  (let ((related-post (make-hash-table :test 'equal)))
    (setf (gethash "_id" related-post) (post-id post)
          (gethash "tags" related-post) (post-tags post)
          (gethash "related" related-post) related)
    related-post))

(defun add-related (posts)
  (let ((tag-map (build-tag-map posts))
        (all-related-posts (make-array (length posts)))
        (shared-counts (make-array (length posts)
                                   :initial-element 0
                                   :element-type '(unsigned-byte 8)))
        (top-counts (make-array +top-n+ :element-type '(unsigned-byte 8) :initial-element 0))
        (top-indices (make-array +top-n+ :element-type 'fixnum :initial-element 0)))
    (dotimes (i (length posts))
      (let* ((post (aref posts i))
             (top-posts-ids (top-related (all-related i posts tag-map shared-counts)
                                         top-counts top-indices))
             (top-posts (map 'list (lambda (id) (aref posts id)) top-posts-ids)))
        (setf (aref all-related-posts i)
              (make-related-post post top-posts))))
    all-related-posts))

(defun now ()
  (float (/ (get-internal-real-time)
            internal-time-units-per-second)))

(defun prepare-for-output (data)
  (declare (type simple-vector data))
  (map 'vector (lambda (rel)
                 (setf (gethash "related" rel)
                       (mapcar (lambda (p)
                                 (let ((h (make-hash-table :test 'equal :size 3)))
                                   (setf (gethash "_id" h) (post-id p)
                                         (gethash "tags" h) (post-tags p)
                                         (gethash "title" h) (post-title p))
                                   h))
                               (gethash "related" rel)))
                 rel)
       data))

(defun main ()
  (let* ((raw-posts (map 'vector
                         (lambda (p)
                           (make-post :id (gethash "_id" p)
                                      :tags (gethash "tags" p)
                                      :title (gethash "title" p)))
                         (the simple-vector
                              (com.inuoe.jzon:parse #p"../posts.json"))))
         (t1 (now))
         (related-posts (add-related raw-posts))
         (t2 (now)))
    (format t "Processing time (w/o IO): ~2$ s~%" (- t2 t1))
    (com.inuoe.jzon:stringify
     (prepare-for-output related-posts)
     :stream #p"../related-cl.json")))

;; Compile and save executable
(save-lisp-and-die "related" :toplevel #'main :executable t :save-runtime-options t)
